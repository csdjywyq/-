## 数据结构：

数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合。在形式上，数据结构通常可以采用一个二元组来表示。数据结构按数据元素之间关系的不同，可以分为以下四类基本结构：

- 集合结构。数据元素属于同一个集合。
- 线性结构。数据元素之间存在着一对一的关系。常见的有链表、队列、栈等。
- 树形结构。数据元素之间存在着一对多的关系。常见的有二叉树、二叉查找树、平衡二叉查找树等。
- 图形结构。数据元素之间存在着多对多的关系。

按照存储方式的不同，数据结构可以分为顺序存储结构和链式存储结构：

1. 顺序存储结构，表示数据元素在存储器中是连续存储的，可以用相对位置来表示数据元素之间的逻辑结构，如顺序表、队列、栈等。
2. 链式存储结构，每个数据元素里设置了一个指针用来指向另一个元素的存储地址，以此来表示数据元素之间的逻辑结构。

按照逻辑结构来分，数据结构可以分为线性结构和非线性结构，如果数据元素之间存在一对一的关系，则称为线性结构，否则称为非线性结构。集合结构、树形结构、图形结构都称为非线性结构。

## 算法：

算法（Algorithm）是对某一个或者某一类问题的解决方案的描述，根据问题的输入，在有限的计算时间里输出预期的结果。不同的算法解决问题所需的时间和空间可能会不同，通常用时间复杂度和空间复杂度来评估算法的优劣。

算法有以下 55 个特征：

- 有穷性。算法必须在执行有限个操作后终止。
- 确切性。算法的每一个操作必须有明确的定义。
- 输入项。算法有零个或多个输入，描述算法的初始状态。
- 输出项。算法有一个或多个输出，没有输出的算法我们认为是没有意义的。
- 可行性。算法的每个计算操作都可以在有限时间内完成。

### 数据结构和算法的关系？

数据结构描述了数据元素之间的逻辑关系，算法描述了数据元素的操作步骤，数据结构和算法组成了程序世界。数据结构和算法之间是不可分割的关系，数据结构是程序的基础，算法将数据互相联系起来，形成了一套能解决具体问题的方案。

在解决问题时，一般我们会优先确定数据结构，然后再来完善算法，有时也会反过来，根据算法来选择合适的数据结构。选择一个合适的数据结构，可以降低算法的复杂度，提高算法的效率。

### 算法复杂度分析

算法的复杂度是评估算法性能优劣一个重要的指标，可以估算出算法在执行之后所需要的时间和空间。算法的复杂度分为算法的时间复杂度和空间复杂度。

### 时间复杂度：

**时间频度** 是指算法中语句的执行次数，用 $ T(n) $来表示，$n$为问题的规模。

时间频度的表达方法有点复杂，需要更直观的表达方法，于是引入了**时间复杂度**的概念。如果有一个辅助函数 $$f(n)$$，在 $n$ 趋向于无穷大时，$T(n)/f(n)$的极限值为不等于0的常数，则我们近似的将$f(n)$替代$T(n)$，记为$T(n)= \mathcal{O}(f(n))$ ，称为算法的渐进时间复杂度。时间复杂度只关心算法中最耗时的部分，舍去常数部分，通常用简单的函数来表示。

时间复杂度只关心算法中最耗时的部分，舍去常数部分，通常用简单的函数来表示。例如，某算法计算出来$ T(n) = 2n^3 + 4n^2 + n$，则它的时间复杂度为 $\mathcal{O}(n^3)$。按效率从高到低排列，时间复杂度一般有以下几种：

| 常数阶           | 对数阶                | 线性阶           | 线性对数阶             | 平方阶             | 立方阶             | 指数阶             | 阶乘阶            |
| :--------------- | :-------------------- | :--------------- | :--------------------- | :----------------- | :----------------- | :----------------- | :---------------- |
| $\mathcal{O}(1)$ | $\mathcal{O}(\log n)$ | $\mathcal{O}(n)$ | $\mathcal{O}(n\log n)$ | $\mathcal{O}(n^2)$ | $\mathcal{O}(n^3)$ | $\mathcal{O}(2^n)$ | $\mathcal{O}(n!)$ |

#### 示例：

```c++
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            a++;
        }
    }
}
int m = 1;
for (int i = 1; i <= n; i++) {
    m *= i;
}
for (int i = 0; i < m; i++) {
    b++;
}
```

第一段 `for` 循环的时间复杂度为 $\mathcal{O}(n^3)$，第二段 `for` 循环计算结果$ m = n!$，第三段 `for` 循环的时间复杂度 $\mathcal{O}(m) = \mathcal{O}(n!)$。因此这段代码的时间复杂度为 $\mathcal{O}(n^3) $和 $\mathcal{O}(n!) $中的较大值，取$ \mathcal{O}(n!)$。

### 空间复杂度：

算法的空间复杂度是指运行该算法所占用的存储空间大小，记为 $s(n)$，和时间复杂度类似，通常也是取它的渐进空间复杂度，用一个直观的函数来表示。通过空间复杂度，可以预估出算法运行所需的存储空间，包括指令空间、数据空间、动态申请的内存空间等。













